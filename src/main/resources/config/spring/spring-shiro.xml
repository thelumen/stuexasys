<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

    <!--1.Realm实现 -->
    <!-- 扫描自定义Realm ok -->
    <context:component-scan base-package="sunday.common.realm">
        <context:exclude-filter type="annotation"
                                expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>

    <!-- 2.会话ID生成器-->
    <bean id="sessionIdGenerator"
          class="org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"/>

    <!-- 3.会话DAO OK-->
    <bean id="shiroSessionDAO"
          class="org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO">
        <!--非常重要，配置缓存（指定缓存名）-->
        <property name="activeSessionsCacheName"
                  value="shiro"/>
        <property name="sessionIdGenerator"
                  ref="sessionIdGenerator"/>
    </bean>

    <!-- 4.会话Cookie模板 -->
    <bean id="sessionIdCookie"
          class="org.apache.shiro.web.servlet.SimpleCookie">
        <!--cookie的name，取名叫Cookie_yue -->
        <property name="name" value="Cookie_yue"/>
        <property name="httpOnly" value="true"/>
        <!-- maxAge单位，秒，可以设置-1，浏览器关闭就失效 -->
        <property name="maxAge" value="-1"/>
    </bean>

    <!-- 5.会话管理器 OK-->
    <bean id="webSessionManager"
          class="org.apache.shiro.web.session.mgt.DefaultWebSessionManager">
        <!-- session超时时间，单位毫秒 one hour-->
        <property name="globalSessionTimeout" value="3600000"/>
        <property name="deleteInvalidSessions" value="true"/>
        <property name="sessionValidationInterval" value="30000"/>
        <property name="sessionValidationSchedulerEnabled" value="true"/>
        <property name="sessionDAO" ref="shiroSessionDAO"/>
        <property name="sessionIdCookieEnabled" value="true"/>
        <property name="sessionIdCookie" ref="sessionIdCookie"/>
    </bean>

    <!-- 6.安全管理器 OK-->
    <bean id="webSecurityManager"
          class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="realms">
            <list>
                <ref bean="myRealm"/>
            </list>
        </property>
        <!-- shiro缓存的配置cacheManager可选择的值有[shiroEhCacheManager|shiroRedisCacheManager]
         分别是ehcache与redis。ehcache是单机模式，redis可以单机也可以集群，依赖redis配置-->
        <!-- 这里还需要注意一下，如果更换了项目名称，那么以前保存的缓存会出现冲突，要删除原先的缓存，
        如果是ehcache，那么要删除java.io.tmpdir/shiro-ehcache这个目录,如果是redis，那么要删除所有shiroToken_开头的缓存 -->
        <property name="cacheManager" ref="shiroEhCacheManager"/>
        <property name="sessionManager" ref="webSessionManager"/>
        <!--记住我-->
        <property name="rememberMeManager" ref="rememberMeManager"/>
    </bean>

    <!-- 7.Shiro过滤器 核心-->
    <bean id="shiroFilter"
          class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <!-- Shiro的核心安全接口,这个属性是必须的 -->
        <property name="securityManager" ref="webSecurityManager"/>
        <!-- 要求登录时的链接(登录页面地址)，非必须的属性，默认会自动寻找Web工程根目录下的"/navigation.jsp"页面-->
        <property name="loginUrl" value="/users/login"/>
        <!-- 登录成功后要跳转的连接(本例中此属性用不到，因为登录成功后的处理逻辑在LoginController里硬编码) -->
        <!-- <property name="successUrl" value="/" ></property> -->
        <!-- 权限认证失败，则跳转到指定页面 -->
        <property name="unauthorizedUrl" value="/shiro/error/unauthorized"/>
        <!-- Shiro连接约束配置,即过滤链的定义 -->
        <property name="filterChainDefinitions">
            <value>
                <!-- 下面value值的第一个'/'代表的路径是相对于HttpServletRequest.getContextPath()的值来的 -->
                <!--anon 表示匿名访问，不需要认证以及授权-->
                /element/*=anon
                /error/*=anon
                /image/**=anon
                /inc/*=anon
                /jslib/**=anon
                /main/*=anon
                /shiro/error/*=anon
                /shiro/user/*=authc
                /shiro/resource/*=authc
                /shiro/systems/*=authc
                /shiro/return/*=authc
                /shiro/logout=logout
                /study/*=anon
                /users/*=anon
                <!--authc表示需要认证 没有进行身份认证是不能进行访问的-->
                <!-- anon：它对应的过滤器里面是空的,什么都没做,这里.do和.jsp后面的*表示参数,比方说login.jsp?main这种 -->
                <!-- authc：该过滤器下的页面必须验证后才能访问,它是Shiro内置的一个拦截器org.apache.shiro.web.filter.authc.FormAuthenticationFilter -->
            </value>
        </property>
    </bean>

    <!-- 8.保证实现了Shiro内部lifecycle函数的bean执行 OK-->
    <bean id="lifecycleBeanPostProcessor"
          class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

    <!-- 9.开启Shiro注解 OK-->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on="lifecycleBeanPostProcessor">
        <!--如果不配置这个，注解也是开不了的 后加的-->
        <property name="proxyTargetClass" value="true"/>
    </bean>
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="webSecurityManager"/>
    </bean>

    <!--10.shiro异常捕获处理 OK-->
    <bean id="shiroHandlerExceptionResolver"
          class="sunday.common.exception.ShiroHandlerExceptionResolver"/>

    <!--11.remember-me-->
    <bean id="rememberMeCookie"
          class="org.apache.shiro.web.servlet.SimpleCookie">
        <!--取名rememberme的name-->
        <constructor-arg value="Remember_yue"/>
        <property name="httpOnly" value="true"/>
        <!-- 记住我1天 -->
        <property name="maxAge" value="86400"/>
    </bean>

    <!-- 12.rememberMe管理器 -->
    <bean id="rememberMeManager"
          class="org.apache.shiro.web.mgt.CookieRememberMeManager">
        <!-- rememberMe cookie加密的密钥 建议每个项目都不一样 默认AES算法 密钥长度（128 256 512 位）-->
        <property name="cipherKey"
                  value="#{T(org.apache.shiro.codec.Base64).decode('3AvVhmFLUs0KTA3Kprsdag==')}"/>
        <property name="cookie" ref="rememberMeCookie"/>
    </bean>

</beans>